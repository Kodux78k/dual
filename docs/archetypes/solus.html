<!doctype html>
<html lang="pt-BR">
<meta charset="utf-8">
<title>Solus • Octaedro</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  :root {
    --bg: transparent;        /* fundo transparente para integrar com overlay do host */
    --line: #8fd3ff;          /* cor principal Blue‑1 */
    --glow: 24px;             /* força de glow base */
    --bloom: 1;               /* multiplica o blur/sombra para um look mais fotográfico */
    --lineWidth: 1.6;         /* espessura */
    --rotateSpeed: 0.6;       /* rotações por segundo */
  }
  html,body {height:100%}
  body { margin:0; background:var(--bg); overflow:hidden; color:#eaf6ff; font:14px/1.4 ui-sans-serif, system-ui; }
  canvas { position:fixed; inset:0; width:100%; height:100%; display:block; }
  .label {
     position:fixed; left:0; right:0; bottom:10px; text-align:center; 
     letter-spacing:.08em; text-transform:uppercase; font-weight:600; opacity:.8;
     text-shadow:0 0 8px #35b6ff, 0 0 20px #35b6ff;
     pointer-events:none;
  }
</style>
<canvas id="solid"></canvas>
<div class="label">Solus — Octaedro</div>
<script>
(function() {
  // ========= util =========
  const TAU = Math.PI*2;
  const φ = (1+Math.sqrt(5))/2;
  const canvas = document.getElementById('solid');
  const ctx = canvas.getContext('2d');

  function size() {
    const dpr = window.devicePixelRatio||1;
    canvas.width  = Math.floor(innerWidth*dpr);
    canvas.height = Math.floor(innerHeight*dpr);
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    return dpr;
  }
  let DPR = size();
  addEventListener('resize', () => DPR = size());

  // ========= geometry =========
  function solidData(kind) {
    // returns {verts: [x,y,z][], edges: [i,j][]}
    if (kind==='tetra') {
      const v = [
        [ 1, 1, 1],
        [-1,-1, 1],
        [-1, 1,-1],
        [ 1,-1,-1]
      ];
      const e = [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]];
      return {verts:v, edges:e};
    }
    if (kind==='hexa') { // cube
      const v = [];
      for (let x of [-1,1]) for (let y of [-1,1]) for (let z of [-1,1]) v.push([x,y,z]);
      const id = (x,y,z)=> (x+1)/2*4 + (y+1)/2*2 + (z+1)/2;
      const e = [];
      const xs=[-1,1], ys=[-1,1], zs=[-1,1];
      for (let xi=0; xi<2; xi++) for (let yi=0; yi<2; yi++) {
        e.push([id(xs[xi],ys[yi],-1), id(xs[xi],ys[yi],1)]);
      }
      for (let xi=0; xi<2; xi++) for (let zi=0; zi<2; zi++) {
        e.push([id(xs[xi],-1,zs[zi]), id(xs[xi],1,zs[zi])]);
      }
      for (let yi=0; yi<2; yi++) for (let zi=0; zi<2; zi++) {
        e.push([id(-1,ys[yi],zs[zi]), id(1,ys[yi],zs[zi])]);
      }
      return {verts:v, edges:e};
    }
    if (kind==='octa') {
      const v = [
        [ 1, 0, 0],[-1, 0, 0],
        [ 0, 1, 0],[ 0,-1, 0],
        [ 0, 0, 1],[ 0, 0,-1]
      ];
      const e = [[0,2],[0,3],[0,4],[0,5],[1,2],[1,3],[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]];
      return {verts:v, edges:e};
    }
    if (kind==='icosa') {
      const t = φ;
      const v = [
        [-1, t, 0],[ 1, t, 0],[-1,-t, 0],[ 1,-t, 0],
        [ 0,-1, t],[ 0, 1, t],[ 0,-1,-t],[ 0, 1,-t],
        [ t, 0,-1],[ t, 0, 1],[-t, 0,-1],[-t, 0, 1]
      ];
      // normalized
      for(let i=0;i<v.length;i++) {
        const [x,y,z]=v[i]; const m=Math.hypot(x,y,z); v[i]=[x/m,y/m,z/m];
      }
      const e = [
        [0,1],[0,5],[0,7],[0,10],[0,11],
        [1,5],[1,7],[1,8],[1,9],
        [2,3],[2,4],[2,6],[2,10],[2,11],
        [3,4],[3,6],[3,8],[3,9],
        [4,5],[4,9],[4,11],
        [5,9],[5,11],
        [6,7],[6,8],[6,10],
        [7,8],[7,10],
        [8,9],[10,11]
      ];
      return {verts:v, edges:e};
    }
    if (kind==='dodeca') {
      const t = φ;
      // Build from icosa dual. Dodeca vertices are permutations of (±1, ±1, ±1), (0, ±1/φ, ±φ), (±1/φ, ±φ, 0), (±φ, 0, ±1/φ)
      const a = 1/ t;
      const b = t;
      const v = [];
      // (±1, ±1, ±1)
      for (let x of [-1,1]) for (let y of [-1,1]) for (let z of [-1,1]) v.push([x,y,z]);
      // (0, ±a, ±b)
      for (let y of [-a,a]) for (let z of [-b,b]) v.push([0,y,z]);
      for (let y of [-b,b]) for (let z of [-a,a]) v.push([0,y,z]); // (0, ±b, ±a)
      // (±a, ±b, 0)
      for (let x of [-a,a]) for (let y of [-b,b]) v.push([x,y,0]);
      for (let x of [-b,b]) for (let y of [-a,a]) v.push([x,y,0]); // (±b, ±a,0)
      // (±a,0,±b)
      for (let x of [-a,a]) for (let z of [-b,b]) v.push([x,0,z]);
      for (let x of [-b,b]) for (let z of [-a,a]) v.push([x,0,z]); // (±b,0,±a)
      // normalize a bit
      for(let i=0;i<v.length;i++) { const [x,y,z]=v[i]; const m=Math.hypot(x,y,z); v[i]=[x/m,y/m,z/m]; }
      // edges from standard dodeca connectivity (approximate selection to keep wireframe coherent)
      // We'll compute edges by connecting vertices whose distance is close for a dodecahedron.
      const edges=[]; 
      for(let i=0;i<v.length;i++) for(let j=i+1;j<v.length;j++) {
        const [x1,y1,z1]=v[i], [x2,y2,z2]=v[j];
        const d = Math.hypot(x1-x2,y1-y2,z1-z2);
        if (d>0.9 && d<1.35) edges.push([i,j]); // heuristic
      }
      // Limit to a manageable number by removing far edges when too many
      if (edges.length>100) edges.length=100;
      return {verts:v, edges:edges};
    }
    return solidData('octa');
  }

  const params = new URLSearchParams(location.search);
  const kind = (params.get('solid') || 'octa').toLowerCase();
  const glow = Math.max(0, Math.min(1.5, parseFloat(params.get('glow')||'0.8')));
  const bloom = Math.max(0, Math.min(3, parseFloat(params.get('bloom')||'1.0')));
  const lineW = Math.max(0.5, Math.min(4, parseFloat(params.get('lw')||getComputedStyle(document.documentElement).getPropertyValue('--lineWidth'))));
  const rotateSpeed = parseFloat(params.get('rs')||getComputedStyle(document.documentElement).getPropertyValue('--rotateSpeed'));
  const {verts, edges} = solidData(kind);

  // ========= camera & project =========
  let angleX=0, angleY=0;
  function rot([x,y,z], ax, ay) {
    // rotate first around Y (ay), then X (ax)
    const cy=Math.cos(ay), sy=Math.sin(ay), cx=Math.cos(ax), sx=Math.sin(ax);
    let nx =  cy*x + sy*z;
    let nz = -sy*x + cy*z;
    let ny =  cx*y - sx*nz;
    nz =  sx*y + cx*nz;
    return [nx,ny,nz];
  }
  let audioLevel = 0;
  window.addEventListener('message', (e)=>{
     if (e && e.data && typeof e.data.audioLevel==='number') audioLevel = e.data.audioLevel;
  });

  // ========= draw =========
  function draw(t) {
    const w=canvas.width, h=canvas.height;
    ctx.clearRect(0,0,w,h);
    // breathing scale
    const baseS = Math.min(w,h)*0.32;
    const breathe = 1 + 0.10*Math.sin(t*0.002) + 0.35*audioLevel;
    const s = baseS * breathe;

    angleX = t*0.001*TAU*rotateSpeed*0.2;
    angleY = t*0.001*TAU*rotateSpeed*0.3;

    // project
    const proj = [];
    for (let i=0; i<verts.length; i++) {
      const [x,y,z] = rot(verts[i], angleX, angleY);
      const d = 3/(z+3.8); // simple perspective
      proj.push([ w/2 + x*s*d, h/2 + y*s*d, d ]);
    }

    // glow layers
    ctx.lineCap='round';
    ctx.lineJoin='round';
    const baseAlpha = 0.85;
    const layers = 4;
    for (let L=layers; L>=1; L--) {
      ctx.beginPath();
      for (const [i,j] of edges) {
        const [x1,y1] = proj[i], [x2,y2] = proj[j];
        ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      }
      ctx.strokeStyle = 'rgba(143,211,255,'+(baseAlpha*(L/layers))+')';
      ctx.lineWidth = (lineW + (L-1)*1.2) * DPR;
      ctx.shadowColor = 'rgba(53,182,255,'+(0.45*glow*(L/layers))+')';
      ctx.shadowBlur = (10 + 18*L) * glow * bloom * DPR;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    // core crisp lines
    ctx.beginPath();
    for (const [i,j] of edges) {
      const [x1,y1] = proj[i], [x2,y2] = proj[j];
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
    }
    ctx.strokeStyle = 'rgba(220,245,255,0.92)';
    ctx.lineWidth = lineW * DPR;
    ctx.stroke();

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();
</script>
