<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>KOBLLUX — Nebula Masterclass · Inline Shader + Sigil</title>
<style>
:root{
  --bg:#000; --fg:#eaf2ff; --mut:#9aa6b2;
  --grad-a:#ff52e5; --grad-b:#00c5e5;
}
*{box-sizing:border-box}html,body{height:100%}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Montserrat',sans-serif;color:var(--fg);background:var(--bg);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
#appRoot{position:relative;min-height:100vh;display:grid;place-items:center;overflow:hidden}

/* Top-centered theme toggle (outline circle 33x33) */
.theme-toggle{
  position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:140;
  width:33px;height:33px;border-radius:50%;border:2px solid rgba(255,255,255,.12);
  display:grid;place-items:center;background:transparent;cursor:pointer;backdrop-filter:blur(2px);
}

/* global glow controlled by orb center */
.orb-global-glow{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:1200px;height:1200px;border-radius:50%;pointer-events:none;z-index:0;background:radial-gradient(circle at 40% 35%, var(--grad-a) 0%, var(--grad-b) 40%, rgba(0,0,0,0) 60%);filter:blur(120px) saturate(1.05);mix-blend-mode:screen;opacity:.95}

/* Splash orb center */
#splash{position:absolute;inset:0;display:grid;place-items:center;z-index:10}
.orbe{width:180px;aspect-ratio:1;border-radius:999px;cursor:pointer;position:relative;
  background:radial-gradient(circle at 30% 25%, var(--grad-a) 0%, var(--grad-b) 65%, #001a22 100%);
  box-shadow:0 0 120px rgba(0,197,229,.35), inset 0 0 100px rgba(255,82,229,.22);
  animation:orbepulse 2.2s ease-in-out infinite;filter:drop-shadow(0 10px 40px rgba(0,0,0,.6))}
@keyframes orbepulse{0%,100%{transform:scale(1)}50%{transform:scale(1.06)}}

/* HUD and panels */
.hud{position:fixed;left:14px;top:14px;display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:12px;background:rgba(0,0,0,.28);box-shadow:0 12px 34px rgba(0,0,0,.6);z-index:120}
.btn{appearance:none;border:0;background:rgba(255,255,255,.04);color:var(--fg);padding:6px 10px;border-radius:10px;cursor:pointer}
.btn-ghost{background:transparent;border:1px dashed rgba(255,255,255,.06)}

/* Sigil area */
#sigilPanel{position:fixed;right:14px;top:84px;width:320px;z-index:160}
.sigil-card{background:rgba(255,255,255,.02);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,.03)}
.sigil-preview{width:260px;height:260px;display:block;margin:8px auto;border-radius:8px;background:#06060a}

/* Canvas */
#kx3gs{position:fixed;inset:0;z-index:0;pointer-events:none;background:var(--bg)}
canvas{width:100%;height:100%}

/* Modal */
#masterclassModal{display:none;position:fixed;inset:0;z-index:13000;align-items:center;justify-content:center;background:rgba(0,0,0,0.6)}
.modal-card{width:min(880px,96vw);max-height:86vh;overflow:auto;background:#071017;padding:22px;border-radius:12px;border:1px solid rgba(255,255,255,0.02);box-shadow:0 30px 80px rgba(0,0,0,.8)}
.master-title{font-weight:800;font-size:1.25rem;color:var(--grad-a);margin-bottom:6px}
.master-body p{line-height:1.6;color:#dfe9f6}
</style>
</head>
<body>
<div id="appRoot">
  <div class="orb-global-glow" aria-hidden="true"></div>
  <button class="theme-toggle" id="themeToggle" aria-label="Trocar tema" title="Trocar tema (Dark)"></button>

  <section id="splash" aria-label="splash"><div class="orbe" id="splashOrbe" title="Toque" role="button" aria-pressed="false"></div></section>

  <main id="spaceStage" role="main" aria-label="Espaço" style="display:none">
    <div class="hud" role="toolbar" aria-label="HUD KOBLLUX">
      <button id="btnOrbe" class="btn" aria-label="Abrir Orbe/Config">Orbe</button>
      <div class="hud-title">KOBLLUX — Nebula Space</div>
      <button id="btnMaster" class="btn-ghost" title="Abrir Masterclass">Masterclass</button>
    </div>

    <section id="panelKx" style="top:84px;left:50%;transform:translateX(-50%);width:min(720px,94vw);position:fixed;z-index:140;background:rgba(255,255,255,0.02);padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,0.03)">
      <div style="font-weight:700">KOBLLUX — Fundação</div>
    </section>

    <div id="kxRodaViva" style="display:none;position:fixed;inset:0;z-index:120;place-items:center;"></div>

    <div id="sigilPanel">
      <div class="sigil-card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>SIGILO</strong>
          <div><button id="btnGenSigil" class="btn">Gerar</button></div>
        </div>
        <div id="sigilPreviewWrap"><svg id="sigilPreview" class="sigil-preview" viewBox="0 0 260 260" xmlns="http://www.w3.org/2000/svg"></svg></div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:8px"><button id="btnDownloadSigil" class="btn">Baixar SVG</button><button id="btnCopySigil" class="btn-ghost">Copiar</button></div>
      </div>
    </div>

  </main>
</div>

<canvas id="kx3gs"></canvas>

<!-- Masterclass modal -->
<div id="masterclassModal" role="dialog" aria-modal="true">
  <div class="modal-card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><div class="master-title">Masterclass KOBLLUX</div><div style="opacity:.8">o app-organismo: do vazio ao loop consciente</div></div>
      <div><button id="btnCloseMaster" class="btn-ghost">Fechar</button></div>
    </div>
    <div style="height:12px"></div>
    <div class="master-body"><p>Versão ritual — fundo totalmente escuro, partículas e sigilos integrados.</p></div>
  </div>
</div>

<script>
/* Inline WebGL particle field (no Three.js) + Sigil generator + UI glue
   - Background is pure dark (#000), glow from orb influences particle tone.
   - Sigil generator creates a deterministic SVG from activation seed.
*/
(function(){
  'use strict';
  const $ = (s,r=document)=>r.querySelector(s);

  // Archetypes with hue mapping
  const ARCH = [
    {key:'cuidador', label:'Cuidador', hue:185, color:'#39ffb6', freq:432},
    {key:'criador', label:'Criador', hue:145, color:'#5CFF6A', freq:528},
    {key:'heroi', label:'Herói', hue:20, color:'#FF6B6B', freq:396},
    {key:'prestativo', label:'Prestativo', hue:40, color:'#FFC857', freq:639},
    {key:'mago', label:'Mago', hue:210, color:'#7EC8FF', freq:741},
    {key:'explorador', label:'Explorador', hue:195, color:'#64E3FF', freq:852},
    {key:'rebelde', label:'Rebelde', hue:350, color:'#FF5C8A', freq:285},
    {key:'inocente', label:'Inocente', hue:320, color:'#F3C1FF', freq:963},
    {key:'amante', label:'Amante', hue:330, color:'#FF71CF', freq:528},
    {key:'orfao', label:'Órfão', hue:0, color:'#A0A7B3', freq:417},
    {key:'transformador', label:'Transformador', hue:190, color:'#00C5E5', freq:741},
    {key:'sabio', label:'Sábio', hue:265, color:'#9D7BFF', freq:888}
  ];

  // Simple hash/PRNG
  function hashString(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h = Math.imul(h ^ s.charCodeAt(i), 16777619); } return h >>> 0; }
  function rngFrom(n){ let v = n>>>0; return function(){ v = Math.imul(v ^ (v << 13), 0x5bd1e995)>>>0; return (v / 4294967295); }; }

  // UI elements
  const splash = $('#splash'), orbe = $('#splashOrbe'), space = $('#spaceStage');
  const themeToggle = $('#themeToggle');
  const modal = $('#masterclassModal'), btnMaster = $('#btnMaster'), btnCloseMaster = $('#btnCloseMaster');
  const btnGenSigil = $('#btnGenSigil'), sigPreview = $('#sigilPreview'), btnDownloadSigil = $('#btnDownloadSigil'), btnCopySigil = $('#btnCopySigil');

  // Onboard: show space after pressing orb
  function showSpace(){ if(splash) splash.style.display='none'; if(space) space.style.display='block'; }
  orbe && orbe.addEventListener('click', showSpace, {passive:true});
  // If previously onboarded, show space
  if(localStorage.getItem('dual.onboard.ok')==='1'){ showSpace(); } else { /* keep splash */ }

  // Theme toggle: we keep dark only per request, but allow cycling to medium if needed
  let themeIndex = 0; const THEMES = [{name:'dark', bg:'#000'}, {name:'medium', bg:'#071017'}];
  themeToggle && themeToggle.addEventListener('click', ()=>{ themeIndex = (themeIndex+1)%THEMES.length; document.body.style.background = THEMES[themeIndex].bg; });

  // Canvas & WebGL setup
  const canvas = document.getElementById('kx3gs');
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  let gl = canvas.getContext('webgl', { alpha:true, antialias:true }) || canvas.getContext('experimental-webgl');
  let width = 0, height = 0;
  function resize(){ width = Math.max(1, Math.floor(window.innerWidth * dpr)); height = Math.max(1, Math.floor(window.innerHeight * dpr)); canvas.width = width; canvas.height = height; canvas.style.width = window.innerWidth + 'px'; canvas.style.height = window.innerHeight + 'px'; if(gl){ gl.viewport(0,0,width,height); } }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  if(!gl){ console.warn('WebGL not available — particle canvas fallback activated'); /* fallback: simple 2D */ }

  // Create shader program
  function createShader(gl, type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); gl.deleteShader(s); return null; } return s; }
  const vs = [
    'attribute float aId;',
    'uniform vec2 uRes; uniform float uTime; uniform float uHue;',
    'varying float vId; varying vec2 vPos;',
    'float rand(float n){ return fract(sin(n)*43758.5453123); }',
    'void main(){',
    '  float id = aId; vId = id; float r1 = rand(id*17.0); float r2 = rand(id*113.0); float ang = uTime*(0.2 + r2*1.2) + r1*6.28318; float layer = mix(0.4,1.0,fract(r1)); float radius = 0.15 + r1*0.85;',
    '  float x = radius * cos(ang) * layer; float y = radius * sin(ang) * layer * 0.58;',
    '  vec2 px = vec2((x*0.9 + 0.5) * uRes.x, (y*0.9 + 0.5) * uRes.y);',
    '  vec2 ndc = vec2(px.x / uRes.x * 2.0 - 1.0, px.y / uRes.y * 2.0 - 1.0);',
    '  vPos = vec2(x,y); gl_PointSize = mix(1.5, 3.8, layer); gl_Position = vec4(ndc, 0.0, 1.0);',
    '}'
  ].join('\n');
  const fs = [
    'precision mediump float;',
    'uniform float uHue; uniform float uAlpha; uniform vec2 uRes; uniform vec2 uOrbe; varying vec2 vPos;',
    'vec3 hsl2rgb(float h,float s,float l){ float c=(1.0-abs(2.0*l-1.0))*s; float x=c*(1.0-abs(mod(h*6.0,2.0)-1.0)); float m=l-0.5*c; vec3 rgb; if(h<1.0/6.0) rgb=vec3(c,x,0.0); else if(h<2.0/6.0) rgb=vec3(x,c,0.0); else if(h<3.0/6.0) rgb=vec3(0.0,c,x); else if(h<4.0/6.0) rgb=vec3(0.0,x,c); else if(h<5.0/6.0) rgb=vec3(x,0.0,c); else rgb=vec3(c,0.0,x); return rgb + m; }',
    'void main(){ vec2 p = gl_PointCoord*2.0-1.0; float d = dot(p,p); float a = exp(-3.0*d); vec3 col = hsl2rgb(uHue,1.0,0.55); float distOrbe = distance(vPos, uOrbe); float glow = 1.0 - smoothstep(0.0, 0.9, distOrbe); float alpha = a * uAlpha * (0.3 + 0.7*glow); gl_FragColor = vec4(col, alpha); }'
  ].join('\n');

  let program = null, buffers = null, startTime = performance.now();

  function initGL(){
    if(!gl) return;
    const vert = createShader(gl, gl.VERTEX_SHADER, vs);
    const frag = createShader(gl, gl.FRAGMENT_SHADER, fs);
    if(!vert || !frag) return;
    program = gl.createProgram(); gl.attachShader(program, vert); gl.attachShader(program, frag); gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){ console.error('Program link error', gl.getProgramInfoLog(program)); return; }
    gl.useProgram(program);
    // attributes + buffers
    const N = 800;
    const ids = new Float32Array(N);
    for(let i=0;i<N;i++) ids[i] = i+1;
    const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, ids, gl.STATIC_DRAW);
    const aId = gl.getAttribLocation(program, 'aId'); gl.enableVertexAttribArray(aId); gl.vertexAttribPointer(aId, 1, gl.FLOAT, false, 0, 0);
    // uniforms
    program.uTime = gl.getUniformLocation(program, 'uTime');
    program.uRes = gl.getUniformLocation(program, 'uRes');
    program.uHue = gl.getUniformLocation(program, 'uHue');
    program.uAlpha = gl.getUniformLocation(program, 'uAlpha');
    program.uOrbe = gl.getUniformLocation(program, 'uOrbe');
    program.uRes && gl.uniform2f(program.uRes, width, height);
    program.uAlpha && gl.uniform1f(program.uAlpha, 0.9);
  }

  initGL();

  function renderGL(now){
    if(!gl || !program) return;
    const t = (now - startTime) * 0.001;
    gl.clearColor(0,0,0,0); gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(program);
    gl.uniform1f(program.uTime, t);
    // map orbe position into particle space (-1..1 normalized coordinates roughly)
    const rect = orbe.getBoundingClientRect();
    const cx = (rect.left + rect.width/2 - window.innerWidth/2) / (window.innerWidth/2);
    const cy = -(rect.top + rect.height/2 - window.innerHeight/2) / (window.innerHeight/2);
    // convert to local normalized radius (matching shader's radius scale ~ -1..1)
    const orbeX = cx*0.6, orbeY = cy*0.6;
    gl.uniform2f(program.uOrbe, orbeX, orbeY);
    // hue (use default ARCH center hue if present)
    const hue = 200/360; gl.uniform1f(program.uHue, hue);
    gl.uniform2f(program.uRes, width, height);
    gl.drawArrays(gl.POINTS, 0, 800);
    requestAnimationFrame(renderGL);
  }
  if(gl && program){ requestAnimationFrame(renderGL); }

  // Fallback 2D if no WebGL/program
  if(!gl || !program){
    const ctx = canvas.getContext('2d');
    const particles = [];
    const W = canvas.width, H = canvas.height;
    for(let i=0;i<400;i++){ particles.push({x: Math.random()*W, y: Math.random()*H, r:1+Math.random()*3, vx:(Math.random()-0.5)*0.6, vy:(Math.random()-0.5)*0.6}); }
    (function tick(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(const p of particles){ p.x += p.vx; p.y += p.vy; if(p.x<0) p.x=canvas.width; if(p.x>canvas.width) p.x=0; if(p.y<0) p.y=canvas.height; if(p.y>canvas.height) p.y=0;
        const g = ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,p.r*6); g.addColorStop(0,'rgba(127,63,255,0.9)'); g.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,p.r*6,0,Math.PI*2); ctx.fill(); }
      requestAnimationFrame(tick);
    })();
  }

  // Sigil generator: deterministic SVG based on seed (string)
  function genSigil(seedStr){
    const h = hashString(seedStr || (Date.now().toString())); const rnd = rngFrom(h);
    const W = 260, H = 260, cx = W/2, cy = H/2;
    const N = 7 + Math.floor(rnd()*6);
    const points = [];
    for(let i=0;i<N;i++){ const ang = (i/N)*Math.PI*2 + rnd()*0.6; const r = 40 + rnd()*70; points.push({x:cx + r*Math.cos(ang), y:cy + r*Math.sin(ang)}); }
    // build polygon path + inner star lines
    let path = `M ${points[0].x.toFixed(1)} ${points[0].y.toFixed(1)}`;
    for(let i=1;i<points.length;i++){ path += ` L ${points[i].x.toFixed(1)} ${points[i].y.toFixed(1)}`; }
    path += ' Z';
    // pick two hues
    const a = Math.floor(rnd()*ARCH.length), b = Math.floor(rnd()*ARCH.length);
    const hueA = ARCH[a].hue, hueB = ARCH[b].hue;
    const gradId = 'g'+(h%100000);
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
    <defs>
      <radialGradient id="${gradId}" cx="35%" cy="28%" r="70%"><stop offset="0%" stop-color="${ARCH[a].color}"/><stop offset="100%" stop-color="${ARCH[b].color}"/></radialGradient>
      <filter id="glow"><feDropShadow dx="0" dy="0" stdDeviation="6" flood-color="${ARCH[a].color}" flood-opacity="0.55"/></filter>
    </defs>
    <rect width="100%" height="100%" fill="#000"/>
    <g filter="url(#glow)">
      <circle cx="${cx}" cy="${cy}" r="${30 + Math.floor(rnd()*30)}" fill="url(#${gradId})" />
      <path d="${path}" fill="none" stroke="${ARCH[b].color}" stroke-width="2.6" stroke-linejoin="round" stroke-linecap="round" opacity="0.95"/>
    </g>
    </svg>`;
    return svg;
  }

  function updateSigilPreview(svgStr){
    if(!sigPreview) return;
    sigPreview.innerHTML = svgStr;
  }

  btnGenSigil && btnGenSigil.addEventListener('click', ()=>{
    const seed = prompt('Semente do sigilo (texto curto) — deixar em branco cria aleatório:');
    const svg = genSigil(seed || String(Date.now()));
    updateSigilPreview(svg);
    try{ localStorage.setItem('dual.user.symbol', svg); }catch(e){}
  }, {passive:true});

  btnDownloadSigil && btnDownloadSigil.addEventListener('click', ()=>{
    const svg = sigPreview.innerHTML || genSigil(String(Date.now()));
    const blob = new Blob([svg], {type:'image/svg+xml'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'sigilo.svg'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),500);
  }, {passive:true});

  btnCopySigil && btnCopySigil.addEventListener('click', async ()=>{
    const svg = sigPreview.innerHTML || genSigil(String(Date.now()));
    try{ await navigator.clipboard.writeText(svg); alert('SVG copiado para a área de transferência'); }catch(e){ alert('Falha ao copiar'); }
  }, {passive:true});

  // load last sigil if any
  try{ const last = localStorage.getItem('dual.user.symbol'); if(last) updateSigilPreview(last); }catch(e){}

  // Masterclass modal
  btnMaster && btnMaster.addEventListener('click', ()=>{ if(modal) modal.style.display='flex'; }, {passive:true});
  const btnClose = $('#btnCloseMaster'); btnClose && btnClose.addEventListener('click', ()=>{ if(modal) modal.style.display='none'; }, {passive:true});

  // ensure canvas sizing and start simple render loop
  resize();

  // export for debugging
  window.KOBLLUX = window.KOBLLUX || {}; window.KOBLLUX.Sigil = { gen: genSigil };

})(); // end
</script>
</body>
</html>
